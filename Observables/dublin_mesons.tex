\documentclass[a4paper]{article}

\usepackage{bm}
\usepackage{amsmath}
\usepackage{latexsym}


\newcommand{\tr}{\mathrm{tr}}
\newcommand{\gR}{\mathbf{R}}
\newcommand{\gr}{\mathbf{r}}
\newcommand{\point}{\; .}
\newcommand{\comma}{\; ,}
\newcommand{\leftna}{\left< \right. \left< \right.}
\newcommand{\rightna}{\left. \right> \left. \right>}

\begin{document}



\section{Formule generali}



\subsection{Correlatori mesonici di isotripletto}

Indico con $u$ e $d$ i due flavours fermionici. Sono interessato al calcolo dei correlatori mesonici:
\begin{eqnarray}
&& C_{AB}(x-y) = \left<
\left( \bar{u} \Gamma_A d \right)^\dagger(x)
\left( \bar{u} \Gamma_B d \right)(y)
\right> = \nonumber \\
&& \quad = \left<
\left( \bar{d} \gamma_0 \Gamma_A^\dagger \gamma_0 u \right)(x)
\left( \bar{u} \Gamma_B d \right)(y)
\right> = \nonumber \\
&& \quad = \left<
\left( \bar{d} \bar{\Gamma}_A u \right)(x)
\left( \bar{u} \Gamma_B d \right)(y)
\right>
\end{eqnarray}
dove le matrici $\Gamma$ sono generici prodotti di matrici $\gamma$ e $\bar{\Gamma} = \gamma_0 \Gamma^\dagger \gamma_0$.

Se indico con $G(x,y)$ la matrice inversa dell'operatore di Dirac, se definisco la matrice hermitiana $K(x,y) = G(x,y) \gamma_5$, i campi fermionici possono essere integrati esplicitamente e resta
\begin{eqnarray}
&& C_{AB}(x-y) = - \left< \tr
\left[ \bar{\Gamma}_A G(x,y) \Gamma_B G(y,x) \right]
\right> = \nonumber \\
&& \quad = - \left< \tr
\left[ \gamma_5 \bar{\Gamma}_A K(x,y) \gamma_5 \Gamma_B K(y,x) \right]
\right> \point
\end{eqnarray}

Infine, il correlatore a momento nullo si ottiene mediando sulle time-slices:
\begin{eqnarray}
&& C_{AB}(t) = - \frac{1}{T V_3^2} \sum_{t_0,\mathbf{x},\mathbf{y}}
\left< \tr
\left[ \gamma_5 \bar{\Gamma}_A K(\mathbf{x},t_0,\mathbf{y},t_0+t) \gamma_5 \Gamma_B K(\mathbf{y},t_0+t,\mathbf{x},t_0) \right]
\right> \point \nonumber \\
&&
\end{eqnarray}




\subsection{Correlatori mesonici di isosingoletto}

Il canale di isosingoletto ha un termine in pi\`{u} nel calcolo del correlatore (il termine di \textit{hairpin}). Si ottiene infatti:
\begin{eqnarray}
&& C_{AB}(x-y) = \left<
\left( \bar{u} \Gamma_A u \right)^\dagger(x)
\left( \bar{u} \Gamma_B u \right)(y)
\right> = \nonumber \\
&& \quad = \left<
\left( \bar{u} \bar{\Gamma}_A u \right)(x)
\left( \bar{u} \Gamma_B u \right)(y)
\right> = \nonumber \\
&& \quad = - \left< \tr
\left[ \bar{\Gamma}_A G(x,y) \Gamma_B G(y,x) \right]
\right> + \nonumber \\
&& \quad \quad + \left<
\tr \left[ \bar{\Gamma}_A G(x,x) \right] \tr \left[ \Gamma_B G(y,y) \right]
\right> = \nonumber \\
&& \quad = - \left< \tr
\left[ \bar{\Gamma}_A K(x,y) \Gamma_B K(y,x) \right]
\right> + \nonumber \\
&& \quad \quad + \left<
\tr \left[ \gamma_5 \bar{\Gamma}_A K(x,x) \right] \tr \left[ \gamma_5 \Gamma_B K(y,y) \right]
\right> \point
\end{eqnarray}

Il correlatore a momento nullo risulta:
\begin{eqnarray}
&& C_{AB}(t) = - \frac{1}{T V_3^2} \sum_{t_0,\mathbf{x},\mathbf{y}}
\left< \tr
\left[ \gamma_5 \bar{\Gamma}_A K(\mathbf{x},t_0,\mathbf{y},t_0+t) \gamma_5 \Gamma_B K(\mathbf{y},t_0+t,\mathbf{x},t_0) \right]
\right>  + \nonumber \\
&& \quad \quad + \frac{1}{T V_3^2} \sum_{t_0,\mathbf{x},\mathbf{y}}
\left< \tr \left[ \gamma_5 \bar{\Gamma}_A K(\mathbf{x},t_0,\mathbf{x},t_0) \right] \tr \left[ \gamma_5 \Gamma_B K(\mathbf{y},t_0+t,\mathbf{y},t_0+t) \right]
\right> \point \nonumber \\
&&
\end{eqnarray}



\subsection{Matrici $\Gamma$}

Grazie alle regole di anticommutazione delle matrici $\gamma$, \`{e} facile vedere che la matrice $\bar{\Gamma}$ \`{e} uguale a $\Gamma$, a meno di un segno:
\begin{equation} \label{gamma0_adj}
\bar{\Gamma} = s(\Gamma) \Gamma \qquad \textrm{con } s(\Gamma) = \pm 1 \point
\end{equation}

Inoltre, una matrice $\Gamma$ generica ha le seguenti propriet\`{a}:
\begin{enumerate}
\item i suoi elementi di matrice possono essere $0$, $\pm 1$, $\pm i$;
\item \`{e} o completamente reale o completamente immaginaria;
\item per ogni riga esiste un solo elemento non nullo;
\item per ogni colonna esiste un solo elemento non nullo.
\end{enumerate}
Quindi, data una matrice $\Gamma$, \`{e} possibile scrivere:
\begin{equation} \label{gamma_ab}
\Gamma_{\alpha\beta} = t_\alpha(\Gamma) \delta_{\sigma_\alpha(\Gamma), \beta}
\end{equation}
dove $\sigma(\Gamma)$ \`{e} una permutazione di $4$ elementi e $t_\alpha(\Gamma)$ assume valori $\pm 1$ per le matrici $\Gamma$ reali e $\pm i$ per le matrici $\Gamma$ immaginarie.





\section{Metodo ibrido di Dublino}



\subsection{Propagatore all-to-all}

Scompongo in una base di autovettori la matrice $H = \gamma_5 D$:
\begin{equation*}
H(x,y) = \sum_a \lambda_a v_a(x) v_a^\dagger(y) \comma
\end{equation*}
allora la matrice $K = H^{-1}$ si scrive:
\begin{equation*}
K(x,y) = \sum_a \frac{1}{\lambda_a} v_a(x) v_a^\dagger(y) \point
\end{equation*}

Se divido gli autovalori in due set, posso scomporre l'operatore $K$ in due parti:
\begin{equation} \label{K1}
K(x,y) = \sum_{a=1}^{N_{ev}} \frac{1}{\lambda_a} v_a(x) v_a^\dagger(y) + \mathcal{P}K\mathcal{P}
\end{equation}
dove $\mathcal{P}$ \`{e} il proiettore sullo spazio ortogonale ai primi $N_{ev}$ autovettori:
\begin{equation*}
\mathcal{P} = 1 - \sum_{a=1}^{N_{ev}} v_a(x) v_a^\dagger(y) \point
\end{equation*}

Il primo termine della \ref{K1} pu`{o} essere calcolato esplicitamente, mentre il secondo pu\`{o} essere stimato stocasticamente. A tal scopo, bisogna generare $N_r$ pseudofermioni random $\eta_{[r]}$, normalizzati in modo che
\begin{equation*}
\leftna \eta_{[r]}^A \eta_{[s]}^B \rightna = \delta_{rs} \delta^{AB}
\end{equation*}
dove $A$ \`{e} un indice collettivo di reticolo, spin e colore. Prima di scrivere la stima statistica per $\mathcal{P}K\mathcal{P}$, \`{e} possibile applicare la tecnica della \textit{time dilution} per la riduzione della varianza. Innanzi tutto, ogni sorgente $\eta_{[r]}$ si scrive come somma di $N_d = N_T$ pseudofermioni, ognuno con il supporto su una differente time slice (sorgenti diluite):
\begin{equation*}
\eta_{[r]} = \sum_{d=1}^{N_d} \eta_{[r]}^{(d)} \point
\end{equation*}
Poi, ogni sorgente diluita deve essere proiettata sul sottospazio generato da $\mathcal{P}$:
\begin{equation*}
\mathcal{P}\eta_{[r]}^{(d)} \rightarrow \eta_{[r]}^{(d)} \point
\end{equation*}
Infine, per ogni sorgente si calcola il pozzo corrispondente $\xi_{[r]}^{(d)} = H^{-1} \eta_{[r]}^{(d)}$ e si ottiene alla fine la stima stocastica desiderata per l'operatore $K$ (propagatore all-to-all):
\begin{equation} \label{K}
K(x,y) = \sum_{a=1}^{N_{ev}} \frac{1}{\lambda_a} v_a(x) v_a^\dagger(y) + \frac{1}{N_r} \sum_{r=1}^{N_r} \sum_{d=1}^{N_d} \xi_{[r]}^{(d)}(x) \eta_{[r]}^{(d)\dagger}(y)
\end{equation}



\subsection{Correlatore di isotripletto}

Per calcolare la funzione a due punti, bisogna avere a disposizione due stime indipendenti del propagatore, e quindi bisogna generare $N_{gns} = 2N_r$ sorgenti indipendenti $\eta_{[r]}$ e $\tilde{\eta}_{[r]}$.

Nel calcolo del correlatore a momento nullo compaiono dei termini mediati sulle time-slice. Per semplificare la notazione definisco:
\begin{equation*}
\psi^\dagger_1(t) \Gamma \psi_2(t) \equiv \frac{1}{V_3} \sum_{\mathbf{x}} \psi^\dagger_1(\mathbf{x},t) \Gamma \psi_2(\mathbf{x},t)
\end{equation*}

Allora il correlatore \`{e} dato dalla seguente formula:
\begin{eqnarray}
&& C_{AB}(t) = - \frac{1}{T} \sum_{t_0} \Big\{
\sum_{a,b=1}^{N_{ev}}
\left[ \frac{1}{\lambda_a} v_b^\dagger(t_0) \gamma_5 \bar{\Gamma}_A v_a(t_0) \right]
\left[ \frac{1}{\lambda_b} v_a^\dagger(t_0+t) \gamma_5 \Gamma_B v_b(t_0+t) \right]
+ \nonumber \\
&& \quad + 
\sum_{a=1}^{N_{ev}} \frac{1}{N_r} \sum_{r=1}^{N_{r}} \sum_{d=1}^{N_{d}} 
\left[ \frac{1}{\lambda_a} \eta_{[r]}^{(d)\dagger}(t_0) \gamma_5 \bar{\Gamma}_A v_a(t_0) \right]
\left[ v_a^\dagger(t_0+t) \gamma_5 \Gamma_B \xi_{[r]}^{(d)}(t_0+t) \right]
+ \nonumber \\
&& \quad + 
\sum_{b=1}^{N_{ev}} \frac{1}{N_r} \sum_{r=1}^{N_{r}} \sum_{d=1}^{N_{d}}
\left[ v_b^\dagger(t_0) \gamma_5 \bar{\Gamma}_A \tilde{\xi}_{[r]}^{(d)}(t_0) \right]
\left[ \frac{1}{\lambda_b} \tilde{\eta}_{[r]}^{(d)\dagger}(t_0+t) \gamma_5 \Gamma_B v_b(t_0+t) \right]
+ \nonumber \\
&& \quad + 
\frac{1}{N_r^2} \sum_{r,s=1}^{N_{r}} \sum_{d,f=1}^{N_{d}}
\left[ \eta_{[r]}^{(d)\dagger}(t_0) \gamma_5 \bar{\Gamma}_A \tilde{\xi}_{[s]}^{(c)}(t_0) \right]
\left[ \tilde{\eta}_{[s]}^{(c)\dagger}(t_0+t) \gamma_5 \Gamma_B \xi_{[r]}^{(d)}(t_0+t) \right]
\Big\} \point \nonumber \\
&& \label{correlator}
\end{eqnarray}

Infine, \`{e} possibile utilizzare una tecnica di \textit{noise recycling} per ridurre la varianza. Si riuniscono tutte le sorgenti $\{ \eta_{[r]}^{(d)}, \tilde{\eta}_{[s]}^{(c)} \}$ in un unico set $\{ \eta_{[r]}^{(d)} \}$ di $N_{gns} = 2N_r$ elementi. L'ultimo termine nella formula \ref{correlator} del correlatore pu\`{o} essere sostituito da:
\begin{equation} \label{correlator_with_nr}
\dots + \frac{2}{N_{gns} (N_{gns}-1)} \sum_{r<s}^{N_{gns}} \sum_{d,f=1}^{N_{d}}
\left[ \eta_{[r]}^{(d)\dagger}(t_0) \gamma_5 \bar{\Gamma}_A \xi_{[s]}^{(c)}(t_0) \right]
\left[ \eta_{[s]}^{(c)\dagger}(t_0+t) \gamma_5 \Gamma_B \xi_{[r]}^{(d)}(t_0+t) \right] \point
\end{equation}



\subsection{Termine di hairpin}

Il termine di hairpin si ottiene in maniera analoga al correlatore (cambiano solo le contrazioni tra pozzi e sorgenti):
\begin{eqnarray}
&& \Delta C_{AB}(t) = \frac{1}{T} \sum_{t_0} \Big\{
\sum_{a,b=1}^{N_{ev}}
\left[ \frac{1}{\lambda_a} v_a^\dagger(t_0) \gamma_5 \bar{\Gamma}_A v_a(t_0) \right]
\left[ \frac{1}{\lambda_b} v_b^\dagger(t_0+t) \gamma_5 \Gamma_B v_b(t_0+t) \right]
+ \nonumber \\
&& \quad + 
\sum_{a=1}^{N_{ev}} \frac{1}{N_r} \sum_{r=1}^{N_{r}} \sum_{d=1}^{N_{d}} 
\left[ \frac{1}{\lambda_a} v_a^\dagger(t_0) \gamma_5 \bar{\Gamma}_A v_a(t_0) \right]
\left[  \eta_{[r]}^{(d)\dagger}(t_0+t)\gamma_5 \Gamma_B \xi_{[r]}^{(d)}(t_0+t) \right]
+ \nonumber \\
&& \quad + 
\sum_{b=1}^{N_{ev}} \frac{1}{N_r} \sum_{r=1}^{N_{r}} \sum_{d=1}^{N_{d}}
\left[ \tilde{\eta}_{[r]}^{(d)\dagger}(t_0) \gamma_5 \bar{\Gamma}_A \tilde{\xi}_{[r]}^{(d)}(t_0) \right]
\left[ \frac{1}{\lambda_b} v_b^\dagger(t_0+t) \gamma_5 \Gamma_B v_b(t_0+t) \right]
+ \nonumber \\
&& \quad + 
\frac{1}{N_r^2} \sum_{r,s=1}^{N_{r}} \sum_{d,f=1}^{N_{d}}
\left[ \eta_{[r]}^{(d)\dagger}(t_0) \gamma_5 \bar{\Gamma}_A \xi_{[r]}^{(d)}(t_0) \right]
\left[ \tilde{\eta}_{[s]}^{(c)\dagger}(t_0+t) \gamma_5 \Gamma_B \tilde{\xi}_{[s]}^{(c)}(t_0+t) \right]
\Big\} \point \nonumber \\
&& \label{hairpin}
\end{eqnarray}

Il \textit{noise recycling} in questo caso sostituisce l'ultimo termine nella formula \ref{hairpin} con:
\begin{equation} \label{hairpin_with_nr}
\dots + \frac{2}{N_{gns} (N_{gns}-1)} \sum_{r<s}^{N_{gns}} \sum_{d,f=1}^{N_{d}}
\left[ \eta_{[r]}^{(d)\dagger}(t_0) \gamma_5 \bar{\Gamma}_A \xi_{[r]}^{(d)}(t_0) \right]
\left[ \eta_{[s]}^{(c)\dagger}(t_0+t) \gamma_5 \Gamma_B \xi_{[s]}^{(c)}(t_0+t) \right] \point
\end{equation}



\section{Implementazione}

Tutte le funzioni necessarie per il calcolo dei correlatori con la tecnica ibrida di Dublino sono definite in \verb|Observables/dublin_mesons.c|. Di queste, l'unica visibile dall'esterno \`{e} \\
\verb|   void dublin_meson_correlators(complex*** correlator,|\\
\verb|               int n_corr, int n_masses, double *mass, double acc)|\\
dove:\\
\verb|*  complex*** correlator[n_corr][T]| punta a un array tridimensionale \verb|[n_corr][n_masses][T]| che conterr\'{a} i correlatori calcolati dalla funzione;\\
\verb|*  double *mass| \`{e} un array di dimensione \verb|[n_masses]| che contiene i valori delle masse dei quarks;\\
\verb|*  double acc| \`{e} l'errore da utilizzare nell'inversione dell'operatore di Dirac.
\verb| |\\

Nel file \verb|Observables/dublin_mesons.c| sono definite alcune costanti globali, che definiscono i parametri dell'algoritmo.\\
\verb|  n_eingenvalues = | $ N_{ev}$\\
\verb|  n_hp_eigenvalues = | num. di autovalori da calcolare a precisione alta (da usare in \verb|eva|)\\
\verb|  n_global_noisy_sources_per_point = | $ N_r $\\
\verb|  n_global_noisy_sources = | $ N_{gns} $\\
\verb|  n_dilution_slices = T = | $ N_d $\\
\verb|  n_diluted_noisy_sources = | $ N_d N_{gns} $\\
\verb|  n_sources = | $N_{ev} + N_d N_{gns}$ \\
\verb|  n_gamma_matrices = | num. di matrici $\Gamma$ che voglio inserire nei bilineari\\
\verb|  n_correlators = | num. di correlatori che voglio calcolare\\
\verb| |\\

La funzione \verb|meson_correlators| calcola un certo set prestabilito di correlatori mesonici (uno per ogni prefissata combinazione di matrici $\Gamma$ e per ogni valore della massa) e li scrive nell'array \verb|correlator[n_corr][T]|. Nel seguito vengono descritti i vari passaggi intermedi.

\begin{enumerate}

\item Viene allocata la memoria necessaria, chiamando la funzione\\
\verb|   static void all_to_all_quark_propagator_init(int n_masses);|\\
Se $M_c$ \`{e} la memoria necessaria per un numero complesso, allora la memoria totale richiesta \`{e}:
$$ M_c \left\{ N_{\Gamma} \left( N_{ev} +N_d N_{gns} \right)^2 + V \left[ 2+N_{ev}+N_d N_{gns} \left(N_m+1\right) \right] \right\} \point $$

Se il reticolo \`{e} un $ 16^3 \times 32 $, e se $N_{ev}=100$, $N_d=N_T=32$, $N_{gns}=2$, $N_m = 4$, $N_\Gamma = 16 $ e se i numeri reali sono in singola precisione, la memoria richiesta \`{e} di $426 \textrm{ Mb}$. Se voglio raddoppiare il numero di sorgenti random, ho bisogno di $749 \textrm{ Mb}$. Per reticoli o numero di sorgenti pi\`{u} grandi, alcuni risultati intermedi dovranno essere scritti su disco.

\item Vengono calcolati gli $N_{ev}$ autovettori pi\`{u} bassi, chiamando la funzione \verb|eva|, e vengono immagazzinati nell'array \verb|ev|, mentre gli autovalori vengono immagazzinati nell'array \verb|d|.

\item Vengono generate le $N_{gns}$ sorgenti random diluite $\eta_{[r]}^{(d)}$, appartenenti al sottospazio ortogonale ai primi $N_{ev}$ autovalori, e immagazzinate nell'array \verb|noisy_sources|. Questo viene fatto chiamando la funzione\\
\verb|   static void get_time_diluted_sources(suNf_spinor **source)|\\
che genera una sorgente random definita su tutto il reticolo e poi la diluisce; ogni sorgente diluita viene proiettata e scritta in \verb|source|. La funzione presuppone che l'array \verb|ev| sia gi\`{a} stato riempito. Le sorgenti random sono generate con un noise $Z_2$, chiamando la funzione\\
\verb|   static void z2_spinor(suNf_spinor *source)|.\\

\item Vengono calcolati gli  $N_{gns}$ pozzi $\xi_{[r]}^{(d)}$ per ogni valore della massa, e immagazzinati nell'array \verb|noisy_sinks|. Questo viene fatto chiamando la funzione\\
\verb|   static void get_sinks(suNf_spinor *source, suNf_spinor **sink,|\\
\verb|                         int n_masses, double *mass, double acc)|.\\
Attualmente questa funzione usa l'invertitore \verb|MINRES|.

\item Vengono calcolate le matrici $\mathcal{O}^{\alpha\beta}(t)$ nello spazio di spin, contraendo in tutte le possibili sorgenti con tutti i possibili pozzi. Schematicamente:
\begin{eqnarray*}
&& \mathcal{O}^{\alpha\beta}(t) = \frac{1}{V_3} \sum_{\mathbf{x}} \frac{1}{\lambda_b} v^{\alpha\dagger}_a(\mathbf{x},t) v^\beta_b(\mathbf{x},t) \\
&& \mathcal{O}^{\alpha\beta}(t) = \frac{1}{V_3} \sum_{\mathbf{x}} \frac{1}{\lambda_b} \eta^{\alpha\dagger(d)}_{[r]}(\mathbf{x},t) v^\beta_b(\mathbf{x},t) \\
&& \mathcal{O}^{\alpha\beta}(t) = \frac{1}{V_3} \sum_{\mathbf{x}} \frac{1}{N_r} v^{\alpha\dagger}_a(\mathbf{x},t) \xi^{\beta(d)}_{[r]}(\mathbf{x},t) \\
&& \mathcal{O}^{\alpha\beta}(t) = \frac{1}{V_3} \sum_{\mathbf{x}} \frac{1}{N_r} \eta^{\alpha\dagger(d)}_{[r]}(\mathbf{x},t) \xi^{\beta(f)}_{[s]}(\mathbf{x},t) \point
\end{eqnarray*}
Tutte queste contrazioni tra pozzi e sorgenti sono ottenute con la funzione\\
\verb|   static void source_sink_contraction(complex out[][16],|\\
\verb|               suNf_spinor *source, suNf_spinor *sink, double z);|\\
e vengono scritte temporaneamente nella matrice \verb|complex ss[T][16]|. 

\item Vengono calcolate le contrazioni con le matrici $\Gamma$ rilevanti (\verb|n_gamma_matrices| in tutto), secondo la formula:
\begin{eqnarray*}
&& \mathcal{O}^\Gamma(t) = \tr \left[ \mathcal{O}(t) \Gamma \gamma_5 \right]
\end{eqnarray*}
usando le funzioni tipo\\
\verb|   static void *_trace_H(complex* out, complex* smat)|.\\
Gli operatori $\mathcal{O}^\Gamma(t)$ vengono immagazzinati nell'array\\
\verb|   complex meson[n_gamma_matrices][n_sources*n_sources][T]|.

\item Vengono calcolati i correlatori secondo le formule (\ref{correlator}, \ref{correlator_with_nr}), chiamando la funzione\\
\verb|   static void triplet_correlator(complex* out,|\\
\verb|               complex A[][T], complex B[][T])|.\\
Infine vengono calcolati i termini di hairpin secondo le formule (\ref{hairpin}, \ref{hairpin_with_nr}), chiamando la funzione\\
\verb|   static void hairpin(complex* out,|\\
\verb|               complex A[][T], complex B[][T])|.\\


\end{enumerate}






\begin{thebibliography}{99}

%\cite{Foley:2005ac}
\bibitem{Foley:2005ac}
  J.~Foley, K.~Jimmy Juge, A.~O'Cais, M.~Peardon, S.~M.~Ryan and J.~I.~Skullerud,
  %``Practical all-to-all propagators for lattice QCD,''
  Comput.\ Phys.\ Commun.\  {\bf 172}, 145 (2005)
  [arXiv:hep-lat/0505023].
  %%CITATION = CPHCB,172,145;%%

% %\cite{McNeile:2000xx}
% \bibitem{McNeile:2000xx}
%   C.~McNeile and C.~Michael  [UKQCD Collaboration],
%   %``Mixing of scalar glueballs and flavour-singlet scalar mesons,''
%   Phys.\ Rev.\  D {\bf 63}, 114503 (2001)
%   [arXiv:hep-lat/0010019].
%   %%CITATION = PHRVA,D63,114503;%%

% %\cite{Foster:1998vw}
% \bibitem{Foster:1998vw}
%   M.~Foster and C.~Michael  [UKQCD Collaboration],
%   %``Quark mass dependence of hadron masses from lattice QCD,''
%   Phys.\ Rev.\  D {\bf 59}, 074503 (1999)
%   [arXiv:hep-lat/9810021].
%   %%CITATION = PHRVA,D59,074503;%%

% %\cite{Hart:2006ps}
% \bibitem{Hart:2006ps}
%   A.~Hart, C.~McNeile, C.~Michael and J.~Pickavance  [UKQCD Collaboration],
%   %``A lattice study of the masses of singlet 0++ mesons,''
%   Phys.\ Rev.\  D {\bf 74}, 114504 (2006)
%   [arXiv:hep-lat/0608026].
%   %%CITATION = PHRVA,D74,114504;%%

\end{thebibliography}


\end{document}


